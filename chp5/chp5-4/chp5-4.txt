5-4.インデックスについて

5-4-1.インデックスについて
インデックスとはその名前の通り、索引です。リレーションデータベースではデータの検索を高速化させるための技術として使用しています。インデックスを使用することでデータの検索を高速化することができますが、複数フィールドからなるマルチインデックスを一つのテーブルに多く使用していたりすること、パフォーマンスが悪化してしまう場合もありますので、必要最低限のインデックスを作成するように心がけてください。たとえば、顧客マスターなどでは顧客コードだけにインデックスを使用し、顧客名などについてはインデックスを作成しないようにします。数値型のフィールドにもインデックスをつけることはできますが、筆者は文字型の、とりわけCHAR型のフィールドにのみインデックスをつけるようにしています。こういうルールを自分で決めておくことで、意味のないインデックスは作らないようにしているわけです。また、インデックスは後から作ることができますので、必要になってから作成してもいいと思います。
インデックスが必要となる条件は以下のような場合です。

・検索条件が頻繁に列を参照する場合
・結合条件が頻繁に列を参照する場合
・ORDER BY 文が頻繁に列を使い，データをソートする場合

プライマリキーを設定すると自動的にインデックスが作られます。Firebirdでは最高64個まで一つのテーブルにインデックスを作成することができます。SHOW INDEX文を実行することでプライマリキーがインデックスとして作成することが分かります(例5-4-1-1)。Firebirdでは検索時にどのインデックスを使用すればいいかを自動的に選択してくれるクエリオプティマイザ機能が提供されています。つまり有効なインデックスが設定されていれば、検索時にFirebirdサーバーが有益なインデックスを選択してくれるというわけです。
インデックスの作成はCREATE INDEX構文を使用し、昇順、降順の両方を作成することが可能です。

CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]]
INDEX <インデックス名> ON <テーブル名> ( フィールド名1 [, フィールド名2 ...]);

例5-4-1-1.SHOW INDEXでインデックスを確認
	SQL> show index;
	RDB$PRIMARY5 UNIQUE INDEX ON CUSTOMER(CUST_NO)
	RDB$PRIMARY10 UNIQUE INDEX ON JOB(JOBCODE)
	RDB$FOREIGN9 INDEX ON ORDERS(CUST_NO)
	RDB$PRIMARY8 UNIQUE INDEX ON ORDERS(ORDER_NO)
	RDB$PRIMARY11 UNIQUE INDEX ON ORDER_ENTRY(CUST_NO)
	RDB$PRIMARY1 UNIQUE INDEX ON TABLE1(F1)
	RDB$PRIMARY3 UNIQUE INDEX ON TABLE2(F1)
	RDB$PRIMARY4 UNIQUE INDEX ON TABLE3(F1, F2)
	SQL>                  

インデックスが効果的に使われているかどうかは、SET PLAN文を使用することで確認することができます。Firebirdではクエリの方法をプランと呼んでいます。SET PLAN文を使用すると、検索時にどのインデックスを使用しているかを表示してくれます。例5-4-1-2はサンプルのemployee.gdbで給料が10000以上でかつ従業員番号は100以上の社員の名前と名字をを検索した場合です。この場合ではNAMEXというインデックスを使用していることが分かります。NAMEXというインデックスはどんな構造をしているかはSHOW INDEX <インデックス名>で調べることができます。インデックスを使用していない場合、PLAN (NATURAL)と表示されます。

例5-4-1-2.プランの表示
	SQL> connect '/opt/Firebird/examples/employee.gdb';
	WARNING: This database speaks SQL dialect 1 but Client SQL dialect was set to 3.
	Database:  '/opt/Firebird/examples/employee.gdb', User: SYSDBA      

	給料が10000以上でかつ従業員番号は100以上の社員の名前と名字を表示する
	SQL>
	SQL> select last_name, first_name from employee
	CON>        where emp_no >100 and salary >100000
	CON>        order by last_name, first_name;
 
	PLAN (EMPLOYEE ORDER NAMEX)
	 
	LAST_NAME            FIRST_NAME
	==================== ===============
	 
	Bender               Oliver H.
	Cook                 Kevin
	Ferrari              Roberto
	Glon                 Jacques
	Ichida               Yuki
	Osborne              Pierre
	Yamamoto             Takashi

	SQL>
	SQL> show index namex;
	NAMEX INDEX ON EMPLOYEE(LAST_NAME, FIRST_NAME)      


5-4-2.インデックスのメンテナンス
インデックスを持つテーブルにデータが保存されると自動的にインデックスがメンテナンスされ、新しいデータや変更されたデータに合う形に修正されます。しかし、大量のデータの削除・追加が行われるとインデックスの更新が追いつかず効率の悪いインデックスになってしまいます。Firebirdはガーベージコレクションという機能を持っており、データの削除などで空いたスペースを一番後ろの領域に回して、再利用できるようにしていますが、時にはメンテナンスが必要です。メンテナンスの方法としては次のようなものがあります。

・ALTER INDEX文を使用してインデックスを再作成する
・SET STATISTICS文でインデックスの選択性を再計算する
・DROP INDEX文を実行した後、CREATE INDEXでインデックスを再作成する
・gbakユーティリティでデータベースのバックアップ・リストアを行う

一番理想的なのはgbakユーティリティを利用してデータベースのバックアップ・リストアを行う方法ですが、誰かがアクセスしているとできないですし、24時間稼働しているようなシステムではこの方法はできません。運用時間が長いシステムの場合は、SET STATISTICS文を使用するといいでしょう。
SET STATISTICS文を利用するとインデックスの選択性を再計算します。インデックスの選択性とは、テーブルがアクセスされるときにFirebirdサーバーによって行われるオプティマイジングのための計算で、テーブルの個々の行数を元に計算します。これらの情報はキャッシュメモリに格納され、オプティマイザはこのキャッシュメモリにアクセスして、一番最適なクエリの抽出プランを選択します。インデックス付きのフィールドのデータ量が急激に増加または減少するとこの抽出されたプランが最適ではなくなり、パフォーマンスがダウンする可能性があるわけです。SET STATISTICS構文は次の通りです。

	SET STATISTICS INDEX <インデックス名>

この文を実行することで指定された再計算が行われます。ただし、SET STATISTICS文を実行できるのはインデックスを作成したユーザー、SYSDBAユーザー、オペレーションシステムでroot権限を持つユーザーだけとなっています。また、SET STATISTICS文はインデックスを再作成するわけではないので、再作成を行いたいときはALTER INDEX文またはDROP INDEX文とCREATE INDEX文の組み合わせで行ってください。
大量のデータの追加または削除を行うときは、ALTER INDEX文を使用して一旦インデックスを停止にしてしまう方法もあります。この方法を利用すると、データの追加または削除で1行ずつ行われるインデックスの修正が行われなくなり、最後ALTER INDEX文でインデックスを活動状態にしたときに、インデックスの再作成が行われます。ALTER INDEX構文は次の通りです。

	ALTER INDEX <インデックス名> [ACTIVE|INACTIVE]

データのインポート処理などを行うときはこちらの方法が向いていると思われますので、トランザクションの開始と最後にこのような処理を入れてパフォーマンスをあげてみるのもいいでしょう。
最後に作り直すという方法もなります。再作成にはDROP INDEX文とCREATE INDEX文を使用することになります。DROP INDEX構文は次の通りです。

	DROP INDEX <インデックス名> 


ただし、こちらは誰もインデックスを使用していない場合にのみ有効な手段で、インデックスの作成が行われるとその間はCPUパワーがインデックスの作成に奪われてしまうので、システム全体のパフォーマンスが落ちる可能性があります。作り直す方法を利用する場合はクライアントからのアクセスのない時間にバッチ的に行うなどの方法を考えてみるのもいいでしょう。cronコマンドやATコマンドを利用して、メンテナンス用のSQLスクリプトをISQLで実行する方法などもやり方の一つです。
